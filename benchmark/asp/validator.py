import json
import tempfile
from pathlib import Path
from typing import Dict, List
import subprocess
import re
import shutil

try:
    import clingo  # type: ignore
except Exception:  # pragma: no cover
    clingo = None

from benchmark.asp.action_utils import ActionMapper, extract_intention
from benchmark.asp.constraints_collectors import ConstraintsCollector, get_collector


class ASPValidator:
    """
    Minimal clingo-based validator for one-off mode.
    Converts LLM actions into ASP constraints and inspects clingo JSON output.
    """

    def __init__(
        self,
        domain: str,
        domain_dir: Path,
        instance_dir: Path,
        clingo_path: str = "clingo",
        use_clingo_api: bool = False,
        collector: ConstraintsCollector = None,
    ):
        self.domain = domain
        self.domain_dir = domain_dir
        self.instance_dir = instance_dir
        self.clingo_path = clingo_path
        self.use_clingo_api = use_clingo_api and clingo is not None
        self.mapper = ActionMapper(domain)
        self.last_stdout: Optional[str] = None
        self.collector = get_collector(domain, domain_dir, instance_dir, collector)

    def get_input_files(self) -> List[str]:
        """
        Return the list of LP files that will be fed to clingo for this validator.
        Useful for persisting alongside run artifacts.
        """
        return self.collector.collect()

    def _constraints_from_actions(self, actions: List[Dict]) -> str:
        lines: List[str] = []
        for t, action in enumerate(actions):
            subj = action["subject"]
            aid = action["actionId"]
            params = action.get("parameters", [])
            functor = self.mapper.to_asp_functor(aid, params)
            if self.domain == "aladdin":
                if aid in (0, 7, 8):
                    intention = "_"
                else:
                    intention = extract_intention(action.get("character_plan", "")) or "_"
                lines.append(f":- not act({subj}, {functor}, {intention}, {t}).")
            elif self.domain == "western":
                lines.append(f":- not act({subj}, {functor}, {t}).")
                executed_flag = action.get("executed", True)
                if executed_flag:
                    lines.append(f":- not executed({subj}, {functor}, {t}).")
                else:
                    lines.append(f":- executed({subj}, {functor}, {t}).")
            else:  # secret_agent
                lines.append(f":- not act({subj}, {functor}, {t}).")
        return "\n".join(lines)

    def validate_plan(self, actions: List[Dict], maxstep: int = 10, constraints_text: Optional[str] = None, constraints_path: Optional[str] = None) -> Dict:
        """
        Run clingo on a plan that has already been converted to ASP constraints by the parser.

        Args:
            actions: Original parsed actions (kept for signature compatibility; not used here).
            maxstep: Clingo maxstep constant.
            constraints_text: Required ASP constraint block generated by PlanParser.
            constraints_path: Optional path to an existing .lp file to use instead of creating a temp file.
        """
        if constraints_text is None:
            raise ValueError("constraints_text is required; build constraints in PlanParser before validation.")

        asp_constraints = constraints_text
        self.last_constraints = asp_constraints

        if self.use_clingo_api:
            return self._validate_with_api(asp_constraints, maxstep)

        # choose constraint file path
        if constraints_path:
            constraint_path = constraints_path
            # ensure file exists with current content
            Path(constraints_path).write_text(asp_constraints)
        else:
            with tempfile.NamedTemporaryFile("w+", suffix=".lp", delete=False) as tf:
                tf.write(asp_constraints)
                constraint_path = tf.name

        files = self.get_input_files() + [constraint_path]
        cmd = [self.clingo_path, *files, "-c", f"maxstep={maxstep}", "--outf=2", "0"]
        proc = subprocess.run(cmd, capture_output=True, text=True)

        result: Dict = {
            "cmd": cmd,
            "stdout": proc.stdout,
            "stderr": proc.stderr,
            "returncode": proc.returncode,
            "satisfiable": False,
            "nonexec_feedback": [],
            "unjustified": [],
            "open_commitment_frames": [],
            "conflicts": [],
        }
        # stash raw stdout for persistence
        self.last_stdout = proc.stdout

        try:
            data = json.loads(proc.stdout)
            if data.get("Result") == "SATISFIABLE":
                result["satisfiable"] = True
                values = data["Call"][0]["Witnesses"][0]["Value"] if data["Call"] and data["Call"][0]["Witnesses"] else []
                result.update(self._extract_symbols(values))
        except Exception:
            pass
        return result

    def _validate_with_api(self, asp_constraints: str, maxstep: int) -> Dict:
        result: Dict = {
            "used_api": True,
            "satisfiable": False,
            "nonexec_feedback": [],
            "unjustified": [],
            "open_commitment_frames": [],
            "conflicts": [],
            "acts": [],
        }
        ctrl = clingo.Control(["-c", f"maxstep={maxstep}"])
        for f in self._collect_files():
            ctrl.load(f)
        ctrl.add("base", [], asp_constraints)
        ctrl.ground([("base", [])])
        models = []

        def on_model(m):
            models.append([str(s) for s in m.symbols(shown=True)])

        ctrl.solve(on_model=on_model)
        if models:
            result["satisfiable"] = True
            result.update(self._extract_symbols(models[0]))
        # store a minimal raw representation for persistence
        self.last_stdout = json.dumps({"models": models, "satisfiable": result["satisfiable"]})
        return result

    def _extract_symbols(self, values: List[str]) -> Dict:
        nonexec = []
        unjust = []
        open_frames = []
        conflicts = []
        acts = []
        for atom in values:
            if atom.startswith("nonexec_feedback"):
                parsed = self._parse_nonexec(atom)
                nonexec.append(parsed or atom)
            elif atom.startswith("unjustified"):
                parsed = self._parse_unjustified(atom)
                unjust.append(parsed or atom)
            elif atom.startswith("open_commitment_frame"):
                parsed = self._parse_open_frame(atom)
                open_frames.append(parsed or atom)
            elif atom.startswith("conflict"):
                parsed = self._parse_conflict(atom)
                conflicts.append(parsed or atom)
            elif atom.startswith("act("):
                acts.append(atom)
        return {
            "nonexec_feedback": nonexec,
            "unjustified": unjust,
            "open_commitment_frames": open_frames,
            "conflicts": conflicts,
            "acts": acts,
        }

    def _parse_nonexec(self, atom: str) -> Dict:
        # nonexec_feedback("msg", act(subj, action(params), T))
        m = re.match(r'nonexec_feedback\("(.*)",\s*act\(([^,]+),\s*(.+),\s*(\d+)\)\)', atom)
        if not m:
            return {}
        return {
            "message": m.group(1),
            "subject": m.group(2),
            "action": m.group(3),
            "time": int(m.group(4)),
        }

    def _parse_unjustified(self, atom: str) -> Dict:
        # unjustified(Subj, Fluent, Intention, T)
        m = re.match(r'unjustified\(([^,]+),\s*([^,]+),\s*([^,]+),\s*(\d+)\)', atom)
        if not m:
            return {}
        return {
            "subject": m.group(1),
            "fluent": m.group(2),
            "intention": m.group(3),
            "time": int(m.group(4)),
        }

    def _parse_open_frame(self, atom: str) -> Dict:
        m = re.match(r'open_commitment_frame\(([^,]+),\s*([^)]+)\)', atom)
        if not m:
            return {}
        return {"subject": m.group(1), "intention": m.group(2)}

    def _parse_conflict(self, atom: str) -> Dict:
        # conflict(Threatener, Threatened, Link, Action)
        m = re.match(r'conflict\(([^,]+),\s*([^,]+),\s*([^,]+),\s*([^)]+)\)', atom)
        if not m:
            return {}
        return {
            "threatener": m.group(1),
            "threatened": m.group(2),
            "link": m.group(3),
            "action": m.group(4),
        }
