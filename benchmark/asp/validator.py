import json
import tempfile
from pathlib import Path
from typing import Dict, List, Optional
import subprocess
import re
import shutil

try:
    import clingo  # type: ignore
except Exception:  # pragma: no cover
    clingo = None

from benchmark.asp.action_utils import ActionMapper
from benchmark.io.constraints_collectors import BaseConstraintsCollector, get_collector


class ASPValidator:
    """Runs clingo and parses its JSON output."""

    def __init__(
        self,
        domain: str,
        domain_dir: Path,
        instance_dir: Path,
        clingo_path: str = "clingo",
        use_clingo_api: bool = False,
        collector: BaseConstraintsCollector = None,
    ):
        self.domain = domain
        self.domain_dir = domain_dir
        self.instance_dir = instance_dir
        self.clingo_path = clingo_path
        self.use_clingo_api = use_clingo_api and clingo is not None
        self.mapper = ActionMapper(domain)
        self.last_stdout: Optional[str] = None
        self.collector = get_collector(domain, domain_dir, instance_dir, collector)

    def get_input_files(self) -> List[str]:
        return self.clingo_input_files()

    def clingo_input_files(self) -> List[str]:
        return self.collector.collect()

    def validate_plan(self, actions: List[Dict], maxstep: int = 10, constraints_text: Optional[str] = None, constraints_path: Optional[str] = None) -> Dict:
        """
        Run clingo on a plan that has already been converted to ASP constraints by the parser.

        Args:
            actions: Original parsed actions (kept for signature compatibility; not used here).
            maxstep: Clingo maxstep constant.
            constraints_text: Required ASP constraint block generated by PlanParser.
            constraints_path: Optional path to an existing .lp file to use instead of creating a temp file.
        """
        if constraints_text is None:
            raise ValueError("constraints_text is required; build constraints in PlanParser before validation.")

        asp_constraints = constraints_text
        self.last_constraints = asp_constraints

        if self.use_clingo_api:
            return self.validate_with_api(asp_constraints, maxstep)

        # choose constraint file path
        if constraints_path:
            constraint_path = constraints_path
            # ensure file exists with current content
            Path(constraints_path).write_text(asp_constraints)
        else:
            with tempfile.NamedTemporaryFile("w+", suffix=".lp", delete=False) as tf:
                tf.write(asp_constraints)
                constraint_path = tf.name

        files = self.get_input_files() + [constraint_path]
        cmd = [self.clingo_path, *files, "-c", f"maxstep={maxstep}", "--outf=2", "0"]
        proc = subprocess.run(cmd, capture_output=True, text=True)

        result: Dict = {
            "cmd": cmd,
            "stdout": proc.stdout,
            "stderr": proc.stderr,
            "returncode": proc.returncode,
            "satisfiable": False,
            "nonexec_feedback": [],
            "unjustified": [],
            "open_commitment_frames": [],
            "conflicts": [],
        }
        # stash raw stdout for persistence
        self.last_stdout = proc.stdout

        try:
            data = json.loads(proc.stdout)
            if data.get("Result") == "SATISFIABLE":
                result["satisfiable"] = True
                values = data["Call"][0]["Witnesses"][0]["Value"] if data["Call"] and data["Call"][0]["Witnesses"] else []
                result.update(self.extract_symbols(values))
        except Exception:
            pass
        return result

    def validate_with_api(self, asp_constraints: str, maxstep: int) -> Dict:
        result: Dict = {
            "used_api": True,
            "satisfiable": False,
            "nonexec_feedback": [],
            "unjustified": [],
            "open_commitment_frames": [],
            "conflicts": [],
            "acts": [],
        }
        ctrl = clingo.Control(["-c", f"maxstep={maxstep}"])
        for f in self.clingo_input_files():
            ctrl.load(f)
        ctrl.add("base", [], asp_constraints)
        ctrl.ground([("base", [])])
        models = []

        def on_model(m):
            models.append([str(s) for s in m.symbols(shown=True)])

        ctrl.solve(on_model=on_model)
        if models:
            result["satisfiable"] = True
            result.update(self.extract_symbols(models[0]))
        # store a minimal raw representation for persistence
        self.last_stdout = json.dumps({"models": models, "satisfiable": result["satisfiable"]})
        return result

    def extract_symbols(self, values: List[str]) -> Dict:
        nonexec = []
        unjust = []
        open_frames = []
        conflicts = []
        acts = []
        for atom in values:
            if atom.startswith("nonexec_feedback"):
                parsed = self.parse_nonexec(atom)
                nonexec.append(parsed or atom)
            elif atom.startswith("unjustified"):
                parsed = self.parse_unjustified(atom)
                unjust.append(parsed or atom)
            elif atom.startswith("open_commitment_frame"):
                parsed = self.parse_open_frame(atom)
                open_frames.append(parsed or atom)
            elif atom.startswith("conflict"):
                parsed = self.parse_conflict(atom)
                conflicts.append(parsed or atom)
            elif atom.startswith("act("):
                acts.append(atom)
        return {
            "nonexec_feedback": nonexec,
            "unjustified": unjust,
            "open_commitment_frames": open_frames,
            "conflicts": conflicts,
            "acts": acts,
        }

    def parse_nonexec(self, atom: str) -> Dict:
        m = re.match(r'nonexec_feedback\("(.*)",\s*act\(([^,]+),\s*(.+),\s*(\d+)\)\)', atom)
        if not m:
            return {}
        return {
            "message": m.group(1),
            "subject": m.group(2),
            "action": m.group(3),
            "time": int(m.group(4)),
        }

    def parse_unjustified(self, atom: str) -> Dict:
        m = re.match(r'unjustified\(([^,]+),\s*([^,]+),\s*([^,]+),\s*(\d+)\)', atom)
        if not m:
            return {}
        return {
            "subject": m.group(1),
            "fluent": m.group(2),
            "intention": m.group(3),
            "time": int(m.group(4)),
        }

    def parse_open_frame(self, atom: str) -> Dict:
        m = re.match(r'open_commitment_frame\(([^,]+),\s*([^)]+)\)', atom)
        if not m:
            return {}
        return {"subject": m.group(1), "intention": m.group(2)}

    def parse_conflict(self, atom: str) -> Dict:
        if not atom.startswith("conflict(") or not atom.endswith(")"):
            return {}
        inner = atom[len("conflict(") : -1]
        parts = []
        buf = []
        depth = 0
        for ch in inner:
            if ch == "," and depth == 0:
                parts.append("".join(buf).strip())
                buf = []
                continue
            if ch == "(":
                depth += 1
            elif ch == ")":
                depth = max(0, depth - 1)
            buf.append(ch)
        if buf:
            parts.append("".join(buf).strip())
        if len(parts) != 5:
            return {}
        thr, thr_int, targ, targ_int, act = parts
        return {
            "threatener": thr,
            "threatener_intention": thr_int,
            "threatened_actor": targ,
            "threatened_intention": targ_int,
            "action": act,
            "summary": f"{thr} (intends {thr_int}) threatens {targ}'s intention {targ_int} via {act}",
        }
